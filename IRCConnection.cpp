/*  * File:   IRCConnection.cpp * Author: Florian *  * Created on 20. Februar 2015, 23:14 */#include "IRCConnection.h"using namespace std::literals::chrono_literals;IRCConnection::IRCConnection() {}IRCConnection::IRCConnection(const IRCConnection& orig) {}IRCConnection::~IRCConnection() {}int IRCConnection::connectToIRC(std::string server, int port, std::string name, std::string password){    std::cout << "Connecting to: " << server << ":" << port << std::endl;    struct sockaddr_in remoteSocketInfo;    struct hostent *hPtr;    int socketHandle;    const char *remoteHost = server.c_str();    int portNumber = port;    bzero(&remoteSocketInfo, sizeof(sockaddr_in));  // Clear structure memory// Get system information    if((hPtr = gethostbyname(remoteHost)) == NULL)    {        std::cerr << "System DNS name resolution not configured properly." << std::endl;        std::cerr << "Error number: " << ECONNREFUSED << std::endl;        exit(EXIT_FAILURE);    }// Load system information for remote socket server into socket data structures    this->socketH = socket(AF_INET, SOCK_STREAM, 0);    memcpy((char *)&remoteSocketInfo.sin_addr, hPtr->h_addr, hPtr->h_length);    remoteSocketInfo.sin_family = AF_INET;    remoteSocketInfo.sin_port = htons((u_short)portNumber);          if( (connect(this->socketH, (struct sockaddr *)&remoteSocketInfo, sizeof(sockaddr_in)) < 0))    {        std::cerr << "ERROR connecting: " << std::strerror(errno) << std::endl;        close(socketHandle);        exit(EXIT_FAILURE);    }    this->sendToIRC("PASS " + password + "\r\n");    this->sendToIRC("NICK " + name + "\r\n");    this->sendToIRC("USER " + name + " 0 * :Crosant\r\n");    this->sendToIRC("MODE +B\r\n");    std::cout << "REGISTERED" << std::endl;    return this->socketH;}void IRCConnection::sendToIRC(const std::string message){    std::cout << std::time(0) << ": " << message;    long n = write(this->socketH,message.c_str(),message.size());    if (n < 0)          std::cerr << "ERROR writing to socket" << std::endl;}std::string IRCConnection::receiveFromIRC(){    return ReadLine(this->socketH);}std::string IRCConnection::ReadLine (int fd) {    // We read-ahead, so we store in static buffer    // what we already read, but not yet returned by ReadLine.    std::string line;        // Do the real reading from fd until buffer has '\n'.    std::string::iterator pos;    while ((pos = find (buffer.begin(), buffer.end(), '\n')) == buffer.end ()) {        char buf [1025];        long n = read (fd, buf, 1024);        if (n == -1) {    // handle errors            buffer = "";            return "";        }        buf [n] = 0;        buffer += buf;    }        // Split the buffer around '\n' found and return first part.    line = std::string (buffer.begin(), pos);    buffer = std::string (pos + 1, buffer.end());    return line;}