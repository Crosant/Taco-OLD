/* * File:   IRCBot.cpp * Author: Florian * * Created on 20. Februar 2015, 22:45 */#include "IRCBot.h"#include "IRCCommand_NewCommand.h"#include "IRCCommand_Join.h"#include "IRCCommand_Part.h"#include "IRCCommand_Response.h"#include "IRCConnection.h"#include "IRCStatusListener.h"#include "IRCChatListener.h"#include "IRCCommand_Tea.h"#include "IRCCommand_Coffee.h"#include "IRCUser.h"#include "IRCCommand_Rehash.h"#include "IRCCommand_User.h"#include "IRCCommand_Users.h"#include "TwitchListener.h"#include "IRCCommand_Topic.h"#include <boost/property_tree/ptree.hpp>#include <boost/property_tree/json_parser.hpp>/* MySQL Connector/C++ specific headers */#define DBHOST "tcp://127.0.0.1:3306"#define USER "Taco"#define PASSWORD ""#define DATABASE "Taco"using namespace std::literals::chrono_literals;IRCBot::IRCBot() {    this->time = std::time(0);    this->connection = new IRCConnection();    this->driver = get_driver_instance();    this->con = driver->connect(DBHOST, USER, PASSWORD);    stmt = con->createStatement();    stmt->execute("USE " DATABASE);        this->socket = connection->connectToIRC("irc.newerairc.net", 6667, "Taco", "");    this->status = new IRCStatusListener(this);}IRCBot::IRCBot(const IRCBot& orig) {}IRCBot::~IRCBot() {    delete stmt;    delete con;}template <typename T>std::vector<T> as_vector(boost::property_tree::ptree const& pt, boost::property_tree::ptree::key_type const& key){    std::vector<T> r;    for (auto& item : pt.get_child(key))        r.push_back(item.second.get_value<T>());    return r;}void IRCBot::start(){        std::this_thread::sleep_for(2s);    std::thread input(&IRCBot::receive, this);    std::this_thread::sleep_for(1s);    this->connection->sendToIRC("MODE Taco +B\r\n");    std::thread sende(&IRCBot::send, this);        res = stmt->executeQuery("SELECT id, name FROM Teas ORDER BY id ASC");    std::vector<std::string> teas;    while (res->next()) {        teas.push_back(res->getString("name"));    }    IRCCommand *c;    res = stmt->executeQuery("SELECT id, cmd, response, userLevel FROM Commands ORDER BY id ASC");    while (res->next()) {        c = new IRCCommand_Response(res->getString("cmd"), res->getString("response"), this, res->getInt("userLevel"));        this->registerCMD(c);    }    c = new IRCCommand_Rehash("!rehash", this, 2);    this->registerCMD(c);    c = new IRCCommand_NewCommand("!add", this, 1);    this->registerCMD(c);    c = new IRCCommand_Topic("!topic", this, 1);    this->registerCMD(c);    c = new IRCCommand_Tea("!tea", this, teas, 0);    this->registerCMD(c);    c = new IRCCommand_Coffee("!coffee", this, 0);    this->registerCMD(c);    c = new IRCCommand_Join("!join", this, 2);    this->registerCMD(c);    c = new IRCCommand_Part("!part", this, 2);    this->registerCMD(c);        c = new IRCCommand_User("!user", this, 2);    this->registerCMD(c);           c = new IRCCommand_Users("!users", this, 2);    this->registerCMD(c);            res = stmt->executeQuery("SELECT id, chan FROM Chans ORDER BY id ASC");    while (res->next()) {        this->join(res->getString("chan"));        std::this_thread::sleep_for(1s);    }        //this->join("#invisitest");           // this->addUser("Crosant", "!~Crosant@wird.gefressen.im.NewEraIRC.net", 1);        res = stmt->executeQuery("SELECT id, name, host, level, streams FROM User ORDER BY id ASC");    while (res->next()) {                std::string data = res->getString("streams");        if(data == "")            continue;        boost::property_tree::ptree json;        std::istringstream is (data);                boost::property_tree::read_json(is, json);                this->addUser(res->getString("name"), res->getString("host"), res->getInt("level"), as_vector<std::string>(json, "streams"));    }        std::vector<std::string> tmp;        for(IRCUser *u : this->users){        for(std::string s : u->streams){            if(std::find(tmp.begin(), tmp.end(), s) == tmp.end()){                tmp.push_back(s);            }        }    }        twitch = new TwitchListener(this, tmp);    sende.join();    input.join();}void IRCBot::join(std::string chan){    chans.push_back(chan);    chatListeners.push_back(new IRCChatListener(chan, this));}void IRCBot::part(std::string l){    std::transform(l.begin(), l.end(), l.begin(), ::tolower);    chans.erase(std::remove(chans.begin(), chans.end(), l), chans.end());    chatListeners.erase(std::remove_if(chatListeners.begin(), chatListeners.end(), [l](IRCChatListener* I){        if(I->chan == l){            delete I;            return true;        }        return false;    }));}void IRCBot::send(){    long lastsend = std::time(0);    while(true){        while(true){            std::this_thread::sleep_for(1ms);            if(messages.empty())                break;            if(std::time(0) - lastsend < 3)                break;            std::pair<std::string, std::string> p = messages.front();            messages.pop_front();            std::string m = ("PRIVMSG " + p.first + " :" + p.second + "\r\n");            connection->sendToIRC(m);            lastsend = std::time(0);        }    }}void IRCBot::queueMessage(std::string chan, std::string message){    if(message.length() < 400)    messages.push_back(std::make_pair(chan, message));    else{        messages.push_back(std::make_pair(chan, message.substr(0,400)));        messages.push_back(std::make_pair(chan, message.substr(400)));    }}void IRCBot::receive(){        while(true){        std::string in = connection->receiveFromIRC();        std::cout << std::time(0) << ": " << in << std::endl;        std::vector<std::thread> a;        int i = 0;        std::vector<std::string> parts;        boost::split(parts, in, boost::is_any_of(" \t\r\n"), boost::token_compress_on);        if(parts.size() > 3){                        if(parts.at(1) == "PRIVMSG"){                std::string s = parts.at(3).replace(0,1,"");                for(IRCChatListener* l : chatListeners){                    if(boost::iequals(parts.at(2) , l->chan)){                        for(IRCCommand* c : cmds)                        {                            std::string z = c->cmd;                            if(boost::iequals(s, z)){                                std::thread a(&IRCChatListener::Analyze, l, in);                                a.detach();                            }                        }                    }                    i++;                }            }        }        std::thread b(&IRCStatusListener::Analyze, status, in);        b.detach();    }}void IRCBot::registerCMD(IRCCommand *cmd){    cmds.push_back(cmd);}void IRCBot::addUser(std::string u, std::string h, int i, std::vector<std::string>s){    this->users.push_back(new IRCUser(u, h, i, s));}void IRCBot::rehash(){    while(!this->users.empty()){        IRCUser *u = this->users.back();        this->users.pop_back();        delete u;    }    while(!this->cmds.empty()){        IRCCommand *c = this->cmds.back();        this->cmds.pop_back();        delete c;    }    res = stmt->executeQuery("SELECT id, name FROM Teas ORDER BY id ASC");    std::vector<std::string> teas;    while (res->next()) {        teas.push_back(res->getString("name"));    }    IRCCommand *c;    res = stmt->executeQuery("SELECT id, cmd, response, userLevel FROM Commands ORDER BY id ASC");    while (res->next()) {        c = new IRCCommand_Response(res->getString("cmd"), res->getString("response"), this, res->getInt("userLevel"));        this->registerCMD(c);    }    c = new IRCCommand_Rehash("!rehash", this, 1);    this->registerCMD(c);    c = new IRCCommand_NewCommand("!add", this, 1);    this->registerCMD(c);    c = new IRCCommand_Tea("!tea", this, teas, 0);    this->registerCMD(c);    c = new IRCCommand_Coffee("!coffee", this, 0);    this->registerCMD(c);    c = new IRCCommand_Join("!join", this, 1);    this->registerCMD(c);    c = new IRCCommand_Part("!part", this, 1);    this->registerCMD(c);        c = new IRCCommand_Topic("!topic", this, 1);    this->registerCMD(c);            c = new IRCCommand_User("!user", this, 2);    this->registerCMD(c);    res = stmt->executeQuery("SELECT id, name, host, level, streams FROM User ORDER BY id ASC");    while (res->next()) {                std::string data = res->getString("streams");        if(data == "")            continue;        boost::property_tree::ptree json;        std::istringstream is (data);                boost::property_tree::read_json(is, json);                this->addUser(res->getString("name"), res->getString("host"), res->getInt("level"), as_vector<std::string>(json, "streams"));    }        delete twitch;        std::vector<std::string> tmp;        for(IRCUser *u : this->users){        for(std::string s : u->streams){            if(std::find(tmp.begin(), tmp.end(), s) == tmp.end()){                tmp.push_back(s);            }        }    }        twitch = new TwitchListener(this, tmp);}